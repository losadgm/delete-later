ifndef::imagesdir[:imagesdir: ../images]

[[section-design-decisions]]
== Architecture Decisions

ifdef::arc42help[]
[role="arc42help"]
****
.Contents
Important, expensive, large scale or risky architecture decisions including rationales.
With "decisions" we mean selecting one alternative based on given criteria.

Please use your judgement to decide whether an architectural decision should be documented
here in this central section or whether you better document it locally
(e.g. within the white box template of one building block).

Avoid redundancy.
Refer to section 4, where you already captured the most important decisions of your architecture.

.Motivation
Stakeholders of your system should be able to comprehend and retrace your decisions.

.Form
Various options:

* ADR (https://cognitect.com/blog/2011/11/15/documenting-architecture-decisions[Documenting Architecture Decisions]) for every important decision
* List or table, ordered by importance and consequences or:
* more detailed in form of separate sections per decision

.Further Information
See https://docs.arc42.org/section-9/[Architecture Decisions] in the arc42 documentation.
There you will find links and examples about ADR.
****
endif::arc42help[]


=== ADR-001: BFF + internal services (REST)

[options="header",cols="1,3"]
|===
|Field |Description
|Status |icon:check-circle[] APPROVED
|Context |Browser-facing API should be centralized; system is split into webapp (frontend + backend), users, and gamey.
|Decision |Use webapp-backend as a Backend-for-Frontend (BFF); the BFF calls users and gamey via REST.
|Consequences |Browser talks only to BFF; orchestration and cross-cutting concerns (auth, validation, timeouts) are centralized.
|===

=== ADR-002: Internal endpoints between BFF and gamey

[options="header",cols="1,3"]
|===
|Field |Description
|Status |icon:check-circle[] APPROVED
|Context |gamey provides core game logic (win verification + bot move selection); BFF must check health and request moves.
|Decision |Expose a minimal internal HTTP API in gamey: `GET /status` (health), `POST /ybot/choose/{botId}` (YEN/JSON in, move out as JSON).
|Consequences |Small, stable internal surface; requires consistent contracts for YEN and coordinate encoding.
|===

=== ADR-003: YEN/JSON as game state contract + validation in gamey

[options="header",cols="1,3"]
|===
|Field |Description
|Status |icon:check-circle[] APPROVED
|Context |Game state must follow YEN notation; invalid states must be rejected.
|Decision |Exchange game state as JSON following YEN; validate YEN in gamey and return a JSON error on invalid input.
|Consequences |Single source of truth for domain validation; BFF maps validation failures to 4xx for clients.
|===

=== ADR-004: Stateless engine + no game state persistence in M1

[options="header",cols="1,3"]
|===
|Field |Description
|Status |icon:check-circle[] APPROVED
|Context |M1 prioritizes end-to-end functionality; persisting full game states is out of scope for M1.
|Decision |Keep gamey stateless; do not persist game state in M1.
|Consequences |Each request must carry full required state; simpler deployment/testing for M1.
|===

=== ADR-005: API versioning

[options="header",cols="1,3"]
|===
|Field |Description
|Status |icon:times-circle[] NOT APPROVED
|Context |Breaking changes may happen; a versioning policy was proposed early.
|Decision |(Not approved) URL-based versioning and “major bump rules” are not decided yet; avoid committing to `/v1` paths until requirements stabilize.
|Consequences |No premature coupling to a versioning scheme; versioning can be introduced later (or via headers) if needed.
|===

=== ADR-006: JWT signing algorithm

[options="header",cols="1,3"]
|===
|Field |Description
|Status |icon:check-circle[] APPROVED
|Context |The users service acts as the auth server: it issues tokens and also verifies them; the webapp (BFF and/or frontend) receives tokens and may verify them when needed.
|Decision |Use HS256 for JWT signing/verification (shared secret) for M1.
|Consequences |Simple setup and fast verification; secret must be protected across components that verify tokens.
|===

=== ADR-007: Secrets/config injection mechanism

[options="header",cols="1,3"]
|===
|Field |Description
|Status |icon:check-circle[] APPROVED
|Context |Secrets must not be stored in git; configuration must work locally and in CI/CD.
|Decision |Use environment variables for configuration; store sensitive values as GitHub Actions Secrets and inject them into the deployment as env vars; local dev uses dotenv (`.env` not committed).
|Consequences |Consistent secret values across deployments; requires discipline to avoid leaking env values in logs.
|===

=== ADR-008: Error response envelope

[options="header",cols="1,3"]
|===
|Field |Description
|Status |icon:check-circle[] APPROVED
|Context |Multiple services/clients need consistent error handling.
|Decision |Standardize JSON error responses with: `errorCode`, `message`, `requestId`.
|Consequences |Simpler client-side mapping and debugging; requires stable error codes over time.
|===

=== ADR-009: BFF -> Game Service timeouts

[options="header",cols="1,3"]
|===
|Field |Description
|Status |icon:question-circle[] PROPOSED
|Context |Bot computation and network calls may be slow/fail; BFF must stay responsive.
|Decision |Apply timeouts for BFF → gamey requests; allow strictly bounded retries only for safe idempotent operations.
|Consequences |Prevents hanging requests; retries must be conservative to avoid overload during outages.
|===

=== ADR-010: User persistence and minimal user entity

[options="header",cols="1,3"]
|===
|Field |Description
|Status |icon:check-circle[] APPROVED
|Context |users must persist accounts; we need credentials and basic authorization.
|Decision |Persist user accounts; minimal user entity includes: `id`, `username`, `email`, `passwordHash`, `role` (`player`/`admin`) (extra fields TBD).
|Consequences |Enables authentication and basic admin features; requires clear password hashing rules and role-based authorization checks.
|===

=== ADR-011: Client/Server entrypoint and public APIs

[options="header",cols="1,3"]
|===
|Field |Description
|Status |icon:check-circle[] APPROVED
|Context |Client/server architecture: browser client (SPA) calls server APIs over HTTP; we want a single public entrypoint.
|Decision |Expose: `/` for the SPA, plus two public API surfaces: one for user management (register/login/profile/history) and one for game interaction (create/join room, play, etc.); exact path prefixes are stable but versioning is not decided.
|Consequences |Clear boundaries between “user management” and “game” concerns; simpler documentation and security rules per API.
|===

=== ADR-012: Reverse proxy for path-based routing (Nginx)

[options="header",cols="1,3"]
|===
|Field |Description
|Status |icon:question-circle[] PROPOSED
|Context |Single public port must serve the SPA and route requests to backend APIs; full API gateway is overkill.
|Decision |Use Nginx to route by path: `/` → SPA static assets, `/api/...` → BFF (covering both public APIs), optional `/ws/...` → BFF for WebSockets; no API version prefix is assumed.
|Consequences |One clean entrypoint with simple routing rules; adds a lightweight component to configure and maintain.
|===